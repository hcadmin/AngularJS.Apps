{
  "_args": [
    [
      {
        "raw": "../censorify/censorify-0.1.1.tgz",
        "scope": null,
        "escapedName": null,
        "name": null,
        "rawSpec": "../censorify/censorify-0.1.1.tgz",
        "spec": "C:\\Projects\\Lab\\AngularApp\\devguru\\censorify\\censorify-0.1.1.tgz",
        "type": "local"
      },
      "C:\\Projects\\Lab\\AngularApp\\devguru\\readWords"
    ]
  ],
  "_from": "..\\censorify\\censorify-0.1.1.tgz",
  "_id": "censorify@0.1.1",
  "_inCache": true,
  "_location": "/censorify",
  "_phantomChildren": {},
  "_requested": {
    "raw": "../censorify/censorify-0.1.1.tgz",
    "scope": null,
    "escapedName": null,
    "name": null,
    "rawSpec": "../censorify/censorify-0.1.1.tgz",
    "spec": "C:\\Projects\\Lab\\AngularApp\\devguru\\censorify\\censorify-0.1.1.tgz",
    "type": "local"
  },
  "_requiredBy": [
    "#USER"
  ],
  "_resolved": "file:..\\censorify\\censorify-0.1.1.tgz",
  "_shasum": "c89f2f215cbf17e1f0cff2c9cd9ad8931e19216a",
  "_shrinkwrap": null,
  "_spec": "../censorify/censorify-0.1.1.tgz",
  "_where": "C:\\Projects\\Lab\\AngularApp\\devguru\\readWords",
  "author": {
    "name": "Brad Dayle"
  },
  "dependencies": {},
  "description": "Censors words out of text",
  "devDependencies": {},
  "engines": {
    "node": "*"
  },
  "main": "censortext",
  "name": "censorify",
  "optionalDependencies": {},
  "readme": "----------------------\r\nCommand Line Arguments\r\n----------------------\r\n\r\nExample:  ./word-count -b -sort SelectionSort -suf < textfile\r\n\r\n-------------------------\r\nDesign Decisions & Issues\r\n-------------------------\r\nSince we stereotype against english majors, let's avoid writing this in an\r\nessay format...\r\n\r\nQ.  The original BinarySearchTree::Insert() resolves key collosion by\r\noverwriting the old value with the new value.  How does the modified insert\r\nfunctions resolve key collosions?\r\n\r\nA.  The modified insert functions resolve key collosions by adding the new\r\nvalue to the old value.  For example, if there exists a key K with a value 3,\r\nand we wanted to insert a key K with value 2, the Insert function would change\r\nthe value to 3+2=5.  For our word-count, every key is inserted with a value 1.\r\nHowever, it's easy to see that the insert functions allow different changes to\r\nbe made to the existing key-value tree.\r\n    Consequently, the + operator must be overloaded for the ValueType.  \r\n\r\n\r\nClass Hierachy\r\n\r\n\t\t|-------------------------|             |------------|\r\n                |     BinarySearchTree    |--has-a----->|   BSTNode  |\r\n                |-------------------------|             |------------|\r\n                           ^    ^                           ^  ^\r\n                          /      \\                          |  |\r\n                       is-a     is-a                        |  |\r\n                        /          \\                        |  |\r\n                       /           |--------------|         |  |\r\n                      /            |  SplayTree   |-has-a---|  |\r\n                     /             |--------------|            |\r\n                    /                                        is-a \r\n                   /                                           |\r\n    |----------------|                                  |------------|\r\n    |     AVLTree    |--has-a-------------------------->| AVLNode    |\r\n    |----------------|                                  |------------|\r\n   \r\n\r\n\r\n---------\r\nProfiling\r\n---------\r\n\r\nOur expected performance bottlenecks for the word-count program are...\r\n\r\n--------------------\r\nAlgorithmic Analysis\r\n--------------------\r\n",
  "readmeFilename": "README.md",
  "version": "0.1.1"
}
